Hello. You are my AI Backend Mentor.

Your role is to guide me, a developer, through building the complete, production-ready backend for my SaaS application, StudyWise AI. Your primary goal is not just to provide code, but to teach me the "why" behind every decision, ensuring I understand the architecture, best practices, and trade-offs involved.

We will proceed in a step-by-step, modular fashion. After you explain a concept and provide the code for a step, I will review it and reply with "continue" when I am ready for the next one.

Our Tech Stack:

    Language: TypeScript

    Framework: Node.js with Express.js

    Database: PostgreSQL

    ORM: Drizzle ORM

    AI Model Provider: Google Gemini API

Let's begin.

Module 1: The Unshakeable Foundation - Authentication & Project Setup

Your Teaching Goal: To establish that a secure application starts with identity. You will teach me how to set up a professional-grade project structure and implement a secure, token-based authentication system from scratch.

    Step 1.1: Project Scaffolding.

        The Task: Guide me through initializing a new Node.js project with TypeScript, Express, and Drizzle ORM. Set up a logical folder structure (src, routes, controllers, services, db, middleware).

        Your Teaching Goal: Explain why this separation of concerns is critical for building a maintainable and scalable application.

    Step 1.2: Database Schema & User Model.

        The Task: Using Drizzle ORM, generate the schema for our Users table. It should include fields for id, email, passwordHash, createdAt.

        Your Teaching Goal: Explain the importance of never storing plain-text passwords and introduce the concept of password hashing.

    Step 1.3: User Registration.

        The Task: Create the user registration route (POST /api/auth/register) and controller. The service logic should hash the user's password using bcrypt before saving it to the database.

        Your Teaching Goal: Explain how bcrypt works at a high level (salting and hashing) and why it's the industry standard for password security.

    Step 1.4: User Login & JWT Generation.

        The Task: Create the login route (POST /api/auth/login). The logic should find the user by email, compare the provided password with the stored hash using bcrypt.compare, and if successful, generate a JSON Web Token (JWT).

        Your Teaching Goal: Teach me what a JWT is (header, payload, signature). Explain its stateless nature and why it's perfect for modern SPAs, contrasting it with traditional session-based authentication.

    Step 1.5: Protecting Our Routes.

        The Task: Create an authentication middleware. This middleware will check for a valid JWT in the Authorization header of incoming requests. If the token is valid, it will decode the user's ID from the token and attach it to the request object for use in subsequent controllers.

        Your Teaching Goal: Explain the role of middleware in an Express application and how this single function will be used to secure the majority of our future API endpoints.

Module 2: The AI Brain - Intelligent Test Generation Workflow

Your Teaching Goal: To demystify the process of integrating AI into a backend. You will teach me how to use a multi-model strategy to achieve high accuracy and cost-efficiency.

    Step 2.1: The Document Processing Service.

        The Task: First, create a non-AI service that handles file uploads (multer) and extracts clean text from them. Provide the logic for handling PDF (pdf-parse), DOCX (mammoth.js), and TXT/MD files.

        Your Teaching Goal: Explain that pre-processing and cleaning data is a critical first step before sending it to any AI model to ensure reliable output.

    Step 2.2: The AI Orchestrator & Question Generation.

        The Task: Create the AIService. Implement the first AI-powered function: generateQuestions. This function will take the user's parameters (text, question type, count, etc.) and construct a detailed prompt for the gemini-2.5-flash-preview-05-20 model. The prompt must explicitly ask for a structured JSON output, including the crucial "source sentence".

        Your Teaching Goal: Teach me the art of "prompt engineering." Explain why being highly specific with instructions (especially regarding the output format like JSON) is the key to getting reliable, machine-readable results from an LLM.

    Step 2.3: The "Trust But Verify" System.

        The Task: Implement the second AI-powered function: validateAnswer. This function will loop through the questions generated in the previous step. For each question, it will make a separate, much simpler call to gemini-2.5-flash-preview-05-20 with a prompt asking for a simple "YES" or "NO" validation based on the source sentence. The orchestrator will filter out any questions that fail this check.

        Your Teaching Goal: Explain the "multi-model" strategy. Teach me why using smaller, specialized, and cheaper AI calls for validation is more robust and cost-effective than trying to get a single, perfect result from one massive prompt. This is a core concept for building production-grade AI applications.

Module 3: Persistence & Results - Making the App Useful

Your Teaching Goal: To connect our authentication and AI systems to the database, allowing users to save their work and track their progress.

    Step 3.1: Expanding the Database Schema.

        The Task: Using Drizzle, create the schemas for Tests and Questions. The Tests table must have a foreign key relationship to the Users table (userId). The Questions table must have a foreign key to the Tests table.

        Your Teaching Goal: Explain the concept of relational data and why foreign keys are essential for maintaining data integrity.

    Step 3.2: The Test Creation Endpoint.

        The Task: Create the main endpoint (POST /api/tests). This endpoint must be protected by the authentication middleware from Module 1. It will receive the Wizard's input, call the DocumentProcessingService and the AIService from Module 2, and then save the final, validated test and its questions to the database, linking them to the authenticated user's ID.

        Your Teaching Goal: Show how all the previous modules now connect into one cohesive workflow, with the middleware providing the userId needed to save the data correctly.

    Step 3.3: The User's Library & Results.

        The Task: Create the endpoints to manage user data.

            GET /api/library: Fetches all tests belonging to the authenticated user.

            POST /api/tests/:id/results: An endpoint to submit a user's answers, calculate the score, and save the result.

        Your Teaching Goal: Reinforce how the userId attached by the middleware is used in the WHERE clause of our database queries to ensure users can only ever see their own data.